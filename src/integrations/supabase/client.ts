
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://jruzfpymzkzegdhmzwsr.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpydXpmcHltemt6ZWdkaG16d3NyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE4NjM4MTIsImV4cCI6MjA1NzQzOTgxMn0.fo7-t2T6wbPAyzezvZgFjOmu4hEy3T9f4EpR4JxltL0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Helper functions for dashboard data
export async function getAdvertiserDashboardStats(userId: string, timeRange: string) {
  // Get offer data for the advertiser
  const { data: offers } = await supabase
    .from('offers')
    .select('id, name')
    .eq('advertiser_id', userId);

  // Get offer IDs for this advertiser
  const offerIds = offers?.map(offer => offer.id) || [];
  
  // Get time range boundaries
  const now = new Date();
  let startDate = new Date();
  
  switch(timeRange) {
    case '7d':
      startDate.setDate(now.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(now.getDate() - 30);
      break;
    case '90d':
      startDate.setDate(now.getDate() - 90);
      break;
    case 'all':
      startDate = new Date(2000, 0, 1); // Far in the past
      break;
  }
  
  const isoStartDate = startDate.toISOString();
  
  // Get clicks for the advertiser's offers
  const { data: clicks, error: clicksError } = await supabase
    .from('clicks')
    .select('id, offer_id, created_at')
    .in('offer_id', offerIds)
    .gte('created_at', isoStartDate);
  
  if (clicksError) console.error('Error fetching clicks:', clicksError);
  
  // Get conversions for the advertiser's offers
  const { data: conversions, error: convsError } = await supabase
    .from('conversions')
    .select('id, click_id, revenue, created_at')
    .gte('created_at', isoStartDate);
  
  if (convsError) console.error('Error fetching conversions:', convsError);
  
  // Get the click IDs from the conversions
  const clickIds = conversions?.map(conv => conv.click_id) || [];
  
  // Filter valid conversions (only those with clicks from this advertiser's offers)
  const validClicks = clicks?.filter(click => 
    clickIds.includes(click.id)
  ) || [];
  
  // Get affiliate partners
  const { data: affiliateOffers, error: affOffersError } = await supabase
    .from('affiliate_offers')
    .select('id, affiliate_id, offer_id, status')
    .in('offer_id', offerIds);
  
  if (affOffersError) console.error('Error fetching affiliate offers:', affOffersError);
  
  // Get unique affiliate IDs who have applied to this advertiser's offers
  const uniqueAffiliateIds = [...new Set(affiliateOffers?.map(ao => ao.affiliate_id))];
  const pendingAffiliates = affiliateOffers?.filter(ao => ao.status === 'pending') || [];
  const uniquePendingAffiliateIds = [...new Set(pendingAffiliates.map(pa => pa.affiliate_id))];
  
  // Calculate revenue
  const totalRevenue = conversions?.reduce((sum, conv) => sum + (conv.revenue || 0), 0) || 0;
  
  // Calculate performance metrics
  const clickCount = clicks?.length || 0;
  const conversionCount = conversions?.length || 0;
  const conversionRate = clickCount > 0 ? ((conversionCount / clickCount) * 100).toFixed(1) : "0.0";
  
  // Get daily data for charts
  const dailyData = getDailyData(clicks || [], conversions || [], timeRange);
  
  return {
    revenue: Math.floor(totalRevenue),
    clicks: clickCount,
    conversions: conversionCount,
    conversionRate: conversionRate + '%',
    activeOffers: offers?.length || 0,
    totalAffiliates: uniqueAffiliateIds.length,
    pendingAffiliates: uniquePendingAffiliateIds.length,
    averageConversion: conversionRate + '%',
    chartData: dailyData
  };
}

function getDailyData(clicks: any[], conversions: any[], timeRange: string) {
  // Create a map to store data by day
  const dataByDay = new Map();
  
  // Determine how many days to look back
  const daysToLookBack = timeRange === '7d' ? 7 : 
                         timeRange === '30d' ? 30 : 
                         timeRange === '90d' ? 90 : 365;
  
  // Create entries for each day
  const now = new Date();
  for (let i = daysToLookBack - 1; i >= 0; i--) {
    const date = new Date(now);
    date.setDate(date.getDate() - i);
    const dayStr = formatDate(date);
    dataByDay.set(dayStr, { 
      name: dayStr, 
      clicks: 0, 
      conversions: 0, 
      revenue: 0 
    });
  }
  
  // Add click data
  clicks.forEach(click => {
    const clickDate = new Date(click.created_at);
    const dayStr = formatDate(clickDate);
    
    if (dataByDay.has(dayStr)) {
      const dayData = dataByDay.get(dayStr);
      dayData.clicks += 1;
      dataByDay.set(dayStr, dayData);
    }
  });
  
  // Add conversion data
  conversions.forEach(conv => {
    const convDate = new Date(conv.created_at);
    const dayStr = formatDate(convDate);
    
    if (dataByDay.has(dayStr)) {
      const dayData = dataByDay.get(dayStr);
      dayData.conversions += 1;
      dayData.revenue += (conv.revenue || 0);
      dataByDay.set(dayStr, dayData);
    }
  });
  
  // Convert map to array and sort by date
  return Array.from(dataByDay.values());
}

function formatDate(date: Date) {
  // Format: "MM/DD" or for timeRange > 30 days, use "MM/DD/YY"
  const month = date.getMonth() + 1;
  const day = date.getDate();
  return `${month}/${day}`;
}

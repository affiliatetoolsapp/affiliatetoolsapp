
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://jruzfpymzkzegdhmzwsr.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpydXpmcHltemt6ZWdkaG16d3NyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDE4NjM4MTIsImV4cCI6MjA1NzQzOTgxMn0.fo7-t2T6wbPAyzezvZgFjOmu4hEy3T9f4EpR4JxltL0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Helper functions for dashboard data
export async function getAdvertiserDashboardStats(userId: string, timeRange: string) {
  // Get offer data for the advertiser
  const { data: offers } = await supabase
    .from('offers')
    .select('id, name')
    .eq('advertiser_id', userId);

  // Get offer IDs for this advertiser
  const offerIds = offers?.map(offer => offer.id) || [];
  
  // Get time range boundaries
  const now = new Date();
  let startDate = new Date();
  
  switch(timeRange) {
    case '7d':
      startDate.setDate(now.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(now.getDate() - 30);
      break;
    case '90d':
      startDate.setDate(now.getDate() - 90);
      break;
    case 'all':
      startDate = new Date(2000, 0, 1); // Far in the past
      break;
  }
  
  const isoStartDate = startDate.toISOString();
  
  // Get clicks for the advertiser's offers
  const { data: clicks, error: clicksError } = await supabase
    .from('clicks')
    .select('id, offer_id, created_at')
    .in('offer_id', offerIds)
    .gte('created_at', isoStartDate);
  
  if (clicksError) console.error('Error fetching clicks:', clicksError);
  
  // Get conversions for the advertiser's offers
  const { data: conversions, error: convsError } = await supabase
    .from('conversions')
    .select('id, click_id, revenue, created_at')
    .gte('created_at', isoStartDate);
  
  if (convsError) console.error('Error fetching conversions:', convsError);
  
  // Get the click IDs from the conversions
  const clickIds = conversions?.map(conv => conv.click_id) || [];
  
  // Filter valid conversions (only those with clicks from this advertiser's offers)
  const validClicks = clicks?.filter(click => 
    clickIds.includes(click.id)
  ) || [];
  
  // Get affiliate partners
  const { data: affiliateOffers, error: affOffersError } = await supabase
    .from('affiliate_offers')
    .select('id, affiliate_id, offer_id, status')
    .in('offer_id', offerIds);
  
  if (affOffersError) console.error('Error fetching affiliate offers:', affOffersError);
  
  // Get unique affiliate IDs who have applied to this advertiser's offers
  const uniqueAffiliateIds = [...new Set(affiliateOffers?.map(ao => ao.affiliate_id))];
  const pendingAffiliates = affiliateOffers?.filter(ao => ao.status === 'pending') || [];
  const uniquePendingAffiliateIds = [...new Set(pendingAffiliates.map(pa => pa.affiliate_id))];
  
  // Calculate revenue
  const totalRevenue = conversions?.reduce((sum, conv) => sum + (conv.revenue || 0), 0) || 0;
  
  // Calculate performance metrics
  const clickCount = clicks?.length || 0;
  const conversionCount = conversions?.length || 0;
  const conversionRate = clickCount > 0 ? ((conversionCount / clickCount) * 100).toFixed(1) : "0.0";
  
  // Get daily data for charts
  const dailyData = getDailyData(clicks || [], conversions || [], timeRange);
  
  return {
    revenue: Math.floor(totalRevenue),
    clicks: clickCount,
    conversions: conversionCount,
    conversionRate: conversionRate + '%',
    activeOffers: offers?.length || 0,
    totalAffiliates: uniqueAffiliateIds.length,
    pendingAffiliates: uniquePendingAffiliateIds.length,
    averageConversion: conversionRate + '%',
    chartData: dailyData
  };
}

function getDailyData(clicks: any[], conversions: any[], timeRange: string) {
  // Create a map to store data by day
  const dataByDay = new Map();
  
  // Determine how many days to look back
  const daysToLookBack = timeRange === '7d' ? 7 : 
                         timeRange === '30d' ? 30 : 
                         timeRange === '90d' ? 90 : 365;
  
  // Create entries for each day
  const now = new Date();
  for (let i = daysToLookBack - 1; i >= 0; i--) {
    const date = new Date(now);
    date.setDate(date.getDate() - i);
    const dayStr = formatDate(date);
    dataByDay.set(dayStr, { 
      name: dayStr, 
      clicks: 0, 
      conversions: 0, 
      revenue: 0 
    });
  }
  
  // Add click data
  clicks.forEach(click => {
    const clickDate = new Date(click.created_at);
    const dayStr = formatDate(clickDate);
    
    if (dataByDay.has(dayStr)) {
      const dayData = dataByDay.get(dayStr);
      dayData.clicks += 1;
      dataByDay.set(dayStr, dayData);
    }
  });
  
  // Add conversion data
  conversions.forEach(conv => {
    const convDate = new Date(conv.created_at);
    const dayStr = formatDate(convDate);
    
    if (dataByDay.has(dayStr)) {
      const dayData = dataByDay.get(dayStr);
      dayData.conversions += 1;
      dayData.revenue += (conv.revenue || 0);
      dataByDay.set(dayStr, dayData);
    }
  });
  
  // Convert map to array and sort by date
  return Array.from(dataByDay.values());
}

function formatDate(date: Date) {
  // Format: "MM/DD" or for timeRange > 30 days, use "MM/DD/YY"
  const month = date.getMonth() + 1;
  const day = date.getDate();
  return `${month}/${day}`;
}

// Helper function to completely delete an offer and all its related data
export async function deleteOfferCompletely(offerId: string) {
  console.log(`Starting complete deletion process for offer: ${offerId}`);
  
  try {
    // 1. First, delete tracking links that use this offer
    const { data: trackingLinks, error: trackingLinksError } = await supabase
      .from('tracking_links')
      .select('id')
      .eq('offer_id', offerId);
    
    if (trackingLinksError) {
      console.error("Error finding tracking links:", trackingLinksError);
    } else if (trackingLinks && trackingLinks.length > 0) {
      console.log(`Found ${trackingLinks.length} tracking links to delete`);
      const { error: deleteTrackingLinksError } = await supabase
        .from('tracking_links')
        .delete()
        .eq('offer_id', offerId);
      
      if (deleteTrackingLinksError) {
        console.error("Error deleting tracking links:", deleteTrackingLinksError);
        throw deleteTrackingLinksError;
      }
      console.log(`Successfully deleted tracking links`);
    }
    
    // 2. Find clicks associated with this offer
    const { data: clicks, error: clicksError } = await supabase
      .from('clicks')
      .select('id, click_id')
      .eq('offer_id', offerId);
    
    if (clicksError) {
      console.error("Error finding clicks:", clicksError);
    } else if (clicks && clicks.length > 0) {
      console.log(`Found ${clicks.length} clicks to clean up`);
      
      // Get the click_ids to delete associated conversions
      const clickIds = clicks.map(click => click.click_id);
      
      // 3. Delete conversions associated with clicks from this offer
      if (clickIds.length > 0) {
        const { error: deleteConversionsError } = await supabase
          .from('conversions')
          .delete()
          .in('click_id', clickIds);
        
        if (deleteConversionsError) {
          console.error("Error deleting conversions:", deleteConversionsError);
          throw deleteConversionsError;
        }
        console.log(`Successfully deleted associated conversions`);
      }
      
      // 4. Now delete the clicks themselves
      const { error: deleteClicksError } = await supabase
        .from('clicks')
        .delete()
        .eq('offer_id', offerId);
      
      if (deleteClicksError) {
        console.error("Error deleting clicks:", deleteClicksError);
        throw deleteClicksError;
      }
      console.log(`Successfully deleted clicks`);
    }
    
    // 5. Delete affiliate offers (applications) - make a direct delete query instead
    // This is critical to fix the foreign key constraint issue
    const { data: affiliateOffers, error: affiliateOffersError } = await supabase
      .from('affiliate_offers')
      .select('id')
      .eq('offer_id', offerId);
    
    if (affiliateOffersError) {
      console.error("Error finding affiliate offers:", affiliateOffersError);
    } else if (affiliateOffers && affiliateOffers.length > 0) {
      console.log(`Found ${affiliateOffers.length} affiliate applications to delete`);
      
      // Delete each affiliate offer one by one to ensure they're all removed
      for (const affiliateOffer of affiliateOffers) {
        const { error: deleteAffiliateOfferError } = await supabase
          .from('affiliate_offers')
          .delete()
          .eq('id', affiliateOffer.id);
        
        if (deleteAffiliateOfferError) {
          console.error(`Error deleting affiliate offer ${affiliateOffer.id}:`, deleteAffiliateOfferError);
          throw deleteAffiliateOfferError;
        }
      }
      
      console.log(`Successfully deleted affiliate applications`);
    }
    
    // Double-check no more affiliate_offers exist for this offer
    const { data: remainingAffiliateOffers, error: checkError } = await supabase
      .from('affiliate_offers')
      .select('id')
      .eq('offer_id', offerId);
      
    if (checkError) {
      console.error("Error checking remaining affiliate offers:", checkError);
    } else if (remainingAffiliateOffers && remainingAffiliateOffers.length > 0) {
      console.error(`Still found ${remainingAffiliateOffers.length} affiliate offers that couldn't be deleted!`);
      return { success: false, error: "Could not delete all affiliate offers" };
    } else {
      console.log("Verified all affiliate offers were deleted successfully");
    }
    
    // 6. Finally delete the offer itself
    const { error: deleteOfferError } = await supabase
      .from('offers')
      .delete()
      .eq('id', offerId);
    
    if (deleteOfferError) {
      console.error("Error deleting offer:", deleteOfferError);
      throw deleteOfferError;
    }
    
    console.log(`Successfully deleted offer ${offerId}`);
    return { success: true };
  } catch (error) {
    console.error("Error in deleteOfferCompletely:", error);
    return { success: false, error };
  }
}

// Debug helpers
export async function debugCreateOffer(offerData: any) {
  console.log('Attempting to create offer with data:', JSON.stringify(offerData, null, 2));
  
  try {
    const { data, error } = await supabase
      .from('offers')
      .insert(offerData)
      .select()
      .single();
    
    if (error) {
      console.error('Error creating offer:', error);
      return { success: false, error };
    }
    
    console.log('Offer created successfully:', data);
    return { success: true, data };
  } catch (error) {
    console.error('Exception creating offer:', error);
    return { success: false, error };
  }
}
